<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hello Tyler Hall</title>

  <!-- Inter font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg-dark: #04031a;
      --accent-1: #00f5a0;
      --accent-2: #7c4dff;
      --accent-3: #ff3cac;
      --accent-4: #ffd166;
      --glass: rgba(255,255,255,0.06);
    }

    /* Base/reset */
    html,body{
      height:100%;
      margin:0;
      font-family:"Inter",system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      background: var(--bg-dark);
      color: #fff;
      overflow:hidden;
    }

    /* Scene container (full viewport) */
    .scene{
      position:fixed;
      inset:0;
      display:grid;
      place-items:center;
      isolation:isolate; /* keep blend modes local */
    }

    /* Animated layered gradient background */
    .bg-layer{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
      background:
        radial-gradient(1200px 600px at 10% 20%, rgba(124,77,255,0.12), transparent 10%),
        radial-gradient(900px 500px at 90% 80%, rgba(0,245,160,0.10), transparent 10%),
        linear-gradient(135deg, rgba(4,3,26,1) 0%, rgba(10,8,34,1) 50%, rgba(6,5,22,1) 100%);
      transform:translateZ(0);
      overflow:hidden;
    }

    /* Blurred color blobs for depth */
    .bg-blobs{
      position:absolute;
      inset:-10%;
      z-index:0;
      filter: blur(60px) saturate(120%);
      opacity:0.9;
      animation: blobsMove 18s linear infinite;
      background:
        radial-gradient(closest-side, rgba(124,77,255,0.35), transparent 40%),
        radial-gradient(closest-side, rgba(255,60,172,0.30), transparent 35%),
        radial-gradient(closest-side, rgba(0,245,160,0.30), transparent 30%);
      mix-blend-mode: screen;
      transform-origin: center;
    }

    @keyframes blobsMove{
      0%{ transform: translateY(0) scale(1); }
      25%{ transform: translateY(-4%) scale(1.02); }
      50%{ transform: translateY(0) scale(1.05); }
      75%{ transform: translateY(4%) scale(1.02); }
      100%{ transform: translateY(0) scale(1); }
    }

    /* Subtle noise + vignette for depth */
    .bg-overlay{
      position:absolute;
      inset:0;
      z-index:1;
      pointer-events:none;
      background-image:
        radial-gradient(ellipse at center, rgba(0,0,0,0.35), transparent 40%),
        linear-gradient(0deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));
      mix-blend-mode: multiply;
      opacity:0.95;
    }

    /* Particle canvas */
    canvas#particles{
      position:absolute;
      inset:0;
      z-index:1;
      display:block;
      width:100%;
      height:100%;
      pointer-events:none;
      transform: translateZ(0); /* GPU hint */
    }

    /* Centered content */
    .content{
      position:relative;
      z-index:5;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      gap:18px;
      padding: clamp(20px, 3vw, 40px);
      width: min(1200px, 92vw);
      box-sizing:border-box;
    }

    /* Headline styling - big, modern, gradient text with glow */
    .title{
      font-weight:900;
      line-height:0.9;
      margin:0;
      padding:0;
      font-size: clamp(48px, 9vw, 120px);
      letter-spacing: -0.02em;
      transform: translateZ(0);
      background: linear-gradient(90deg, var(--accent-1), var(--accent-2) 30%, var(--accent-3) 60%, var(--accent-4));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow:
        0 8px 40px rgba(0,0,0,0.55),
        0 0 18px rgba(124,77,255,0.18),
        0 0 40px rgba(255,60,172,0.08);
      transform-origin:center;
      will-change:transform;
      transition: transform 0.35s cubic-bezier(.2,.9,.3,1);
    }

    .title:hover{ transform: perspective(600px) translateZ(8px) scale(1.01); }

    /* Subtext */
    .sub{
      color: rgba(255,255,255,0.85);
      font-weight:600;
      font-size: clamp(14px, 1.6vw, 20px);
      opacity:0.95;
      mix-blend-mode: normal;
      text-shadow: 0 2px 8px rgba(0,0,0,0.45);
      margin-top:6px;
    }

    /* Decorative underline glow */
    .underline{
      height:6px;
      width: min(38vw, 420px);
      border-radius:999px;
      margin-top:14px;
      background: linear-gradient(90deg, rgba(0,245,160,0.85), rgba(124,77,255,0.85), rgba(255,60,172,0.85));
      filter: blur(10px) saturate(140%);
      opacity:0.9;
      box-shadow: 0 12px 40px rgba(124,77,255,0.12);
    }

    /* Small hint */
    .hint{
      margin-top:14px;
      color: rgba(255,255,255,0.6);
      font-size:13px;
      letter-spacing:0.02em;
    }

    /* Responsiveness tweaks */
    @media (max-width:520px){
      .underline{ width:70vw; }
      .title{ letter-spacing: -0.01em; }
    }
  </style>
</head>
<body>
  <div class="scene" role="main" aria-label="Animated hello scene">
    <div class="bg-layer" aria-hidden="true"></div>
    <div class="bg-blobs" aria-hidden="true"></div>
    <div class="bg-overlay" aria-hidden="true"></div>

    <!-- Canvas for particles -->
    <canvas id="particles"></canvas>

    <!-- Centered content -->
    <div class="content">
      <h1 class="title">404: Page not found</h1>
      <div class="underline" aria-hidden="true"></div>
      <div class="sub">Lol</div>

    </div>
  </div>

  <script>
    /* ---------------------------------------------------------------------
       High-performance particle system
       - Adaptive particle count based on viewport area
       - Additive blending, soft glow, motion blur trails
       - Mouse interaction: attract + spawn burst
       - Retina support and resize handling
       --------------------------------------------------------------------- */

    (function () {
      const canvas = document.getElementById('particles');
      const ctx = canvas.getContext('2d', { alpha: true });
      let DPR = Math.max(1, window.devicePixelRatio || 1);

      // Config - tweak these to taste
      const CONFIG = {
        particleBase: 80,              // baseline count (scaled by area)
        particleDensityPer100k: 110,   // additional particles per 100k px
        maxParticles: 1500,            // hard cap
        speed: 0.1,                    // base speed multiplier
        sizeMin: 0.8,
        sizeMax: 4.2,
        lifeMin: 6,                    // seconds
        lifeMax: 18,
        trailAlpha: 0.12,              // how much trail the canvas keeps (0-1)
        spawnPerFrame: 2,              // when mouse is active
        colorHueVariance: 40,
      };

      let W = 0, H = 0, area = 0;
      let particles = [];
      let lastTime = performance.now();
      let mouse = { x: null, y: null, vx: 0, vy: 0, down: false, moved: false };
      let adaptTarget = 0;

      function resize() {
        DPR = Math.max(1, window.devicePixelRatio || 1);
        W = Math.max(1, Math.floor(window.innerWidth));
        H = Math.max(1, Math.floor(window.innerHeight));
        area = W * H;
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

        // Determine particle count based on area
        const extra = Math.floor((area / 100000) * CONFIG.particleDensityPer100k);
        adaptTarget = Math.min(CONFIG.maxParticles, CONFIG.particleBase + extra);

        // If we have fewer particles than target, add
        while (particles.length < adaptTarget) particles.push(createParticle(true));
        // If too many, trim
        if (particles.length > adaptTarget) particles.length = adaptTarget;
      }

      // Random range helper
      const rand = (a, b) => a + Math.random() * (b - a);

      function createParticle(initial = false) {
        // Choose a spawn edge or random in view for variety
        const spawnEdge = Math.random();
        let x, y;
        if (initial && Math.random() < 0.6) {
          x = Math.random() * W;
          y = Math.random() * H;
        } else {
          if (spawnEdge < 0.25) { x = Math.random() * W; y = -10; }
          else if (spawnEdge < 0.5) { x = Math.random() * W; y = H + 10; }
          else if (spawnEdge < 0.75) { x = -10; y = Math.random() * H; }
          else { x = W + 10; y = Math.random() * H; }
        }

        const angle = Math.random() * Math.PI * 2;
        const speed = rand(0.2, 1.6) * CONFIG.speed * (1 + Math.random() * 0.8);
        const size = rand(CONFIG.sizeMin, CONFIG.sizeMax);
        const life = rand(CONFIG.lifeMin, CONFIG.lifeMax); // seconds

        // Hue around a sweet range; keep colors matching the page accents
        const baseHue = 275; // base leaning purple
        const hue = (baseHue + rand(-CONFIG.colorHueVariance, CONFIG.colorHueVariance) + 360) % 360;
        const sat = rand(60, 95);
        const light = rand(45, 75);

        return {
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          size,
          life,
          age: initial ? rand(0, life) : 0,
          hue, sat, light,
          alpha: rand(0.5, 1),
          spin: rand(-0.01, 0.01),
        };
      }

      // spawn burst at position (used on mouse)
      function spawnBurst(x, y, count = 16) {
        for (let i = 0; i < count; i++) {
          if (particles.length < CONFIG.maxParticles) {
            const p = createParticle(false);
            p.x = x + rand(-8, 8);
            p.y = y + rand(-8, 8);
            const ang = Math.atan2(p.y - y, p.x - x) + rand(-0.9, 0.9);
            const sp = rand(0.6, 4.2) * CONFIG.speed;
            p.vx = Math.cos(ang) * sp;
            p.vy = Math.sin(ang) * sp;
            p.size = rand(1.4, 5.8);
            p.life = rand(2.2, 6.0);
            particles.push(p);
          }
        }
      }

      // Animation loop
      function animate(now) {
        const dt = Math.min(0.032, (now - lastTime) / 1000);
        lastTime = now;

        // Draw a translucent rectangle to create motion blur trails
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = `rgba(6,5,22, ${Math.max(0.02, CONFIG.trailAlpha)})`;
        ctx.fillRect(0, 0, W, H);

        // Add additive blending for glow
        ctx.globalCompositeOperation = 'lighter';

        // Update and render particles
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          p.age += dt;
          // simple attraction to mouse when present
          if (mouse.x !== null && mouse.moved) {
            const dx = mouse.x - p.x;
            const dy = mouse.y - p.y;
            const dist = Math.sqrt(dx * dx + dy * dy) + 0.001;
            const force = Math.min(120 / dist, 0.9);
            p.vx += (dx / dist) * force * dt * (mouse.down ? 3 : 1.0);
            p.vy += (dy / dist) * force * dt * (mouse.down ? 3 : 1.0);
          } else {
            // subtle wander
            p.vx += Math.sin(p.age * 1.2 + i) * 0.0006;
            p.vy += Math.cos(p.age * 1.6 - i) * 0.0005;
          }

          // Update pos
          p.x += p.vx * (30 * dt);
          p.y += p.vy * (30 * dt);

          // slight spin affects visual (we'll use shadow offset)
          // draw glow circle
          const grd = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, Math.max(1, p.size * 6));
          const color = `hsl(${p.hue}deg ${p.sat}% ${p.light}%)`;
          grd.addColorStop(0, `hsla(${p.hue}deg, ${p.sat}%, ${p.light}%, ${p.alpha})`);
          grd.addColorStop(0.6, `hsla(${p.hue}deg, ${p.sat}%, ${Math.max(30, p.light-20)}%, ${p.alpha * 0.35})`);
          grd.addColorStop(1, `hsla(${p.hue}deg, ${Math.max(30,p.sat-40)}%, ${Math.max(10,p.light-40)}%, 0)`);

          ctx.beginPath();
          ctx.fillStyle = grd;
          ctx.arc(p.x, p.y, p.size * (1 + Math.sin(p.age * 2) * 0.08), 0, Math.PI * 2);
          ctx.fill();

          // Respawn logic when life over or far away
          if (p.age > p.life || p.x < -80 || p.x > W + 80 || p.y < -80 || p.y > H + 80) {
            // replace this particle
            particles[i] = createParticle(false);
          }
        }

        // If mouse active, spawn a few particles to feel alive
        if (mouse.moved && mouse.x !== null) {
          for (let s = 0; s < (mouse.down ? CONFIG.spawnPerFrame * 4 : CONFIG.spawnPerFrame); s++) {
            if (particles.length < CONFIG.maxParticles) {
              const p = createParticle(false);
              p.x = mouse.x + rand(-12,12);
              p.y = mouse.y + rand(-12,12);
              p.vx = (Math.random() - 0.5) * 2.5;
              p.vy = (Math.random() - 0.5) * 2.5;
              p.size = rand(1.2, 4.8);
              particles.push(p);
            }
          }
        }

        // Keep particle array at or below adaptTarget for perf (but allow burst up to max)
        if (particles.length > Math.max(adaptTarget, CONFIG.maxParticles)) particles.length = Math.max(adaptTarget, CONFIG.maxParticles);

        requestAnimationFrame(animate);
      }

      // Mouse/touch handlers
      function onMove(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX ?? e.touches?.[0]?.clientX ?? mouse.x ?? W/2) - rect.left;
        const y = (e.clientY ?? e.touches?.[0]?.clientY ?? mouse.y ?? H/2) - rect.top;
        mouse.moved = true;
        mouse.vx = (x - (mouse.x || x)) * 0.3;
        mouse.vy = (y - (mouse.y || y)) * 0.3;
        mouse.x = x;
        mouse.y = y;
      }
      function onDown(e) {
        mouse.down = true;
        onMove(e);
        spawnBurst(mouse.x || W/2, mouse.y || H/2, 32);
      }
      function onUp() { mouse.down = false; }

      // Init
      function init() {
        resize();
        // initial particle set
        for (let i = 0; i < adaptTarget; i++) particles.push(createParticle(true));
        lastTime = performance.now();
        requestAnimationFrame(animate);

        // events
        window.addEventListener('resize', () => {
          // debounce-ish by requestAnimationFrame
          requestAnimationFrame(resize);
        }, { passive: true });

        window.addEventListener('mousemove', onMove, { passive: true });
        window.addEventListener('pointerdown', onDown, { passive: true });
        window.addEventListener('pointerup', onUp, { passive: true });

        // touch
        window.addEventListener('touchmove', onMove, { passive: true });
        window.addEventListener('touchstart', onDown, { passive: true });
        window.addEventListener('touchend', onUp, { passive: true });

        // leave viewport -> reset mouse to null
        window.addEventListener('mouseleave', () => { mouse.x = null; mouse.y = null; mouse.moved = false; }, { passive: true });

        // If performance dips, reduce particles automatically
        let checkPerfLast = performance.now();
        (function perfCheck() {
          const now = performance.now();
          const elapsed = now - checkPerfLast;
          checkPerfLast = now;
          // adapt target down if frame time too high (simple heuristic)
          // (this reduces adaptTarget to help mobile)
          if (elapsed > 40 && adaptTarget > 220) { adaptTarget = Math.max(180, Math.floor(adaptTarget * 0.92)); }
          requestAnimationFrame(perfCheck);
        })();
      }

      init();
    })();
  </script>
</body>
</html>
