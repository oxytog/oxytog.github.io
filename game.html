<!DOCTYPE html>
<html lang="en">
<head>
    <title>The Maze of Tyler Hall</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .ui-container {
            max-width: 600px;
        }
        h1 {
            font-size: 3em;
            color: #ff4444;
            text-shadow: 0 0 10px #ff0000;
        }
        p {
            font-size: 1.2em;
            line-height: 1.5;
        }
        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        .button {
            background-color: #8B0000;
            border: 2px solid #ff4444;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s, box-shadow 0.3s;
            box-shadow: 0 0 15px #ff0000;
        }
        .button:hover {
            background-color: #ff4444;
            box-shadow: 0 0 25px #ff0000;
        }
        #pause-menu {
            display: none;
        }
        #death-screen {
            display: none;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        #jumpscare-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }
        #death-content {
            position: relative;
            z-index: 20;
            background-color: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 15px;
        }
        #hud {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }
        .bar-container {
            width: 200px;
            height: 20px;
            border: 2px solid #fff;
            border-radius: 5px;
            background-color: rgba(0,0,0,0.5);
            overflow: hidden;
        }
        #stamina-bar {
            width: 100%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.2s ease-in-out;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #b30000;
            transition: width 0.2s ease-in-out;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }
        #damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.5);
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
        }
        @keyframes flash {
            0% { opacity: 0.7; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="damage-flash"></div>
    <div id="blocker">
        <!-- Start Menu with Difficulty Selection -->
        <div id="start-menu" class="ui-container">
            <h1>The Maze</h1>
            <p>Select your difficulty. The deeper you go, the darker it gets.</p>
            <div class="button-grid">
                <div id="easy-button" class="button">Easy</div>
                <div id="medium-button" class="button">Medium</div>
                <div id="hard-button" class="button">Hard</div>
                <div id="extreme-button" class="button">Extreme</div>
            </div>
        </div>
        <!-- Pause Menu -->
        <div id="pause-menu" class="ui-container">
            <h1>Paused</h1>
            <div id="resume-button" class="button">Resume</div>
            <div id="restart-button-pause" class="button">Restart</div>
        </div>
        <!-- Death Screen -->
        <div id="death-screen" class="ui-container">
            <img id="jumpscare-image" src="" alt="You were caught">
            <div id="death-content">
                <h1>You Died</h1>
                <div id="restart-button-death" class="button">Try Again</div>
            </div>
        </div>
    </div>

    <div id="hud">
        <div id="health-bar-container" class="bar-container">
            <div id="health-bar"></div>
        </div>
        <div id="stamina-bar-container" class="bar-container">
            <div id="stamina-bar"></div>
        </div>
    </div>
    <div id="crosshair"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- GAME CONSTANTS ---
        const MAZE_SIZE = 25;
        const WALL_HEIGHT = 5;
        const CELL_SIZE = 5;
        const PLAYER_SPEED = 5.0;
        const PLAYER_SPRINT_SPEED = 9.0;
        const ENEMY_SPEED = 4.8;
        const PLAYER_HEALTH_MAX = 100;
        const STAMINA_MAX = 100;
        const STAMINA_DEPLETE_RATE = 25;
        const STAMINA_REGEN_RATE = 10;
        const MAZE_COMPLEXITY_FACTOR = Math.floor((MAZE_SIZE * MAZE_SIZE) / 15);

        // --- NEW: DIFFICULTY SETTINGS ---
        const DIFFICULTY_SETTINGS = {
            EASY: {
                numEnemies: 1,
                lightIntensity: { hemi: 2.5, ambient: 1.5, player: 6 },
                exitDistanceFactor: 0.25,
                enemyDamage: 25,
                healthRegenRate: 5, // points per second
                damageCooldown: 2 // seconds
            },
            MEDIUM: {
                numEnemies: 2,
                lightIntensity: { hemi: 2.0, ambient: 1.2, player: 5 },
                exitDistanceFactor: 0.5,
                enemyDamage: 35,
                healthRegenRate: 4,
                damageCooldown: 1.5
            },
            HARD: {
                numEnemies: 3,
                lightIntensity: { hemi: 1.5, ambient: 0.8, player: 4 },
                exitDistanceFactor: 0.75,
                enemyDamage: 40,
                healthRegenRate: 3,
                damageCooldown: 1.2
            },
            EXTREME: {
                numEnemies: 4,
                lightIntensity: { hemi: 1.0, ambient: 0.5, player: 3.5 },
                exitDistanceFactor: 0.9,
                enemyDamage: 50,
                healthRegenRate: 2,
                damageCooldown: 1.0
            }
        };

        // --- SCENE SETUP ---
        let scene, camera, renderer, controls;
        let playerObject, playerVelocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, isSprinting = false;
        let lastTime = performance.now();
        const mazeObjects = [];
        let mazeGrid = [];
        let enemies = [];
        let exitLight, hemiLight, ambientLight, playerLight;

        // --- GAME STATE ---
        let gameState = 'MENU';
        let currentDifficulty = 'MEDIUM';
        let playerHealth = PLAYER_HEALTH_MAX;
        let stamina = STAMINA_MAX;
        let damageCooldownTimer = 0;
        
        // --- DOM ELEMENTS ---
        const blocker = document.getElementById('blocker');
        const startMenu = document.getElementById('start-menu');
        const pauseMenu = document.getElementById('pause-menu');
        const deathScreen = document.getElementById('death-screen');
        const resumeButton = document.getElementById('resume-button');
        const restartButtonPause = document.getElementById('restart-button-pause');
        const restartButtonDeath = document.getElementById('restart-button-death');
        const hud = document.getElementById('hud');
        const healthBar = document.getElementById('health-bar');
        const staminaBar = document.getElementById('stamina-bar');
        const crosshair = document.getElementById('crosshair');
        const jumpscareImg = document.getElementById('jumpscare-image');
        const damageFlash = document.getElementById('damage-flash');

        // --- TEXTURES AND MATERIALS ---
        const textureLoader = new THREE.TextureLoader();
        const loadTexture = (primaryUrl, fallbackUrl) => {
            const texture = textureLoader.load(primaryUrl, undefined, undefined, (err) => {
                textureLoader.load(fallbackUrl, (loadedFallbackTexture) => {
                    texture.image = loadedFallbackTexture.image;
                    texture.needsUpdate = true;
                });
            });
            texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping;
            return texture;
        };
        const wallTexture = loadTexture('wall.png', 'https://placehold.co/512x512/333333/555555?text=Wall');
        const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, roughness: 0.7, metalness: 0.2 });
        const floorTexture = loadTexture('floor.png', 'https://placehold.co/512x512/444444/666666?text=Floor');
        const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture, roughness: 0.9, metalness: 0.1 });
        const roofTexture = loadTexture('roof.png', 'https://placehold.co/512x512/1a1a1a/2a2a2a?text=Roof');
        const roofMaterial = new THREE.MeshStandardMaterial({ map: roofTexture });
        const enemyTextureUrl = 'tylerhall.png';
        const enemyTexture = loadTexture(enemyTextureUrl, 'https://placehold.co/256x256/000000/ff0000?text=ENEMY');
        const enemyMaterial = new THREE.MeshBasicMaterial({ map: enemyTexture, transparent: true });
        jumpscareImg.onerror = () => { jumpscareImg.src = 'https://placehold.co/1920x1080/000000/ff0000?text=You+Died'; };
        jumpscareImg.src = enemyTextureUrl;

        // --- INITIALIZATION ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 15, 45);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            controls = new PointerLockControls(camera, renderer.domElement);
            playerObject = controls.getObject();
            scene.add(playerObject);

            hemiLight = new THREE.HemisphereLight(0x888888, 0x000000, 1);
            scene.add(hemiLight);
            ambientLight = new THREE.AmbientLight(0x909090, 1);
            scene.add(ambientLight);
            playerLight = new THREE.PointLight(0xffffff, 1, 35);
            camera.add(playerLight);
            playerLight.position.set(0, 1, 0);

            setupEventListeners();
            animate();
        }

        // --- GAME LOGIC ---
        function startGame(difficulty) {
            currentDifficulty = difficulty;
            const settings = DIFFICULTY_SETTINGS[difficulty];

            hemiLight.intensity = settings.lightIntensity.hemi;
            ambientLight.intensity = settings.lightIntensity.ambient;
            playerLight.intensity = settings.lightIntensity.player;

            mazeObjects.forEach(obj => scene.remove(obj)); mazeObjects.length = 0;
            enemies.forEach(e => scene.remove(e.mesh)); enemies = [];
            if (exitLight) scene.remove(exitLight);
            
            playerVelocity.set(0, 0, 0);
            playerHealth = PLAYER_HEALTH_MAX;
            stamina = STAMINA_MAX;
            updateHealthBar();
            updateStaminaBar();

            mazeGrid = generateMaze(MAZE_SIZE, MAZE_SIZE);
            addComplexityToMaze(mazeGrid);
            removeDeadEnds(mazeGrid);
            buildMaze();

            playerObject.position.set((1 - MAZE_SIZE / 2 + 0.5) * CELL_SIZE, WALL_HEIGHT / 2, (1 - MAZE_SIZE / 2 + 0.5) * CELL_SIZE);
            
            const enemyStartPositions = [ {x: MAZE_SIZE - 2, z: MAZE_SIZE - 2}, {x: 1, z: MAZE_SIZE - 2}, {x: MAZE_SIZE - 2, z: 1}, {x: MAZE_SIZE / 2, z: MAZE_SIZE - 2} ];
            for (let i = 0; i < settings.numEnemies; i++) {
                 const mesh = new THREE.Mesh(new THREE.PlaneGeometry(CELL_SIZE * 0.8, CELL_SIZE * 0.8), enemyMaterial);
                 scene.add(mesh);
                 const startPos = enemyStartPositions[i % enemyStartPositions.length];
                 mesh.position.set((startPos.x - MAZE_SIZE / 2 + 0.5) * CELL_SIZE, WALL_HEIGHT / 2, (startPos.z - MAZE_SIZE / 2 + 0.5) * CELL_SIZE);
                 enemies.push({ mesh, gridX: startPos.x, gridZ: startPos.z, path: [], pathCooldown: Math.random() * 0.5 + 0.2 });
            }
            
            let exitX = Math.max(1, Math.floor(MAZE_SIZE * settings.exitDistanceFactor));
            let exitZ = Math.max(1, Math.floor(MAZE_SIZE * settings.exitDistanceFactor));
            while(mazeGrid[exitZ] && mazeGrid[exitZ][exitX] === 1) {
                exitX++;
                if (exitX >= MAZE_SIZE -1) { exitX = 1; exitZ++; }
                if (exitZ >= MAZE_SIZE - 1) { exitZ = 1; }
            }

            exitLight = new THREE.PointLight(0x00ff00, 5, 10);
            exitLight.position.set((exitX - MAZE_SIZE / 2 + 0.5) * CELL_SIZE, WALL_HEIGHT / 2, (exitZ - MAZE_SIZE / 2 + 0.5) * CELL_SIZE);
            scene.add(exitLight);

            gameState = 'PLAYING';
            hud.style.display = 'flex';
            crosshair.style.display = 'block';
        }
        
        // --- MAZE GENERATION AND PATHFINDING (NO CHANGES) ---
        function generateMaze(w, h) { const m=Array(h).fill(null).map(()=>Array(w).fill(1)),s=[],x=1,z=1;m[z][x]=0;s.push([x,z]);while(s.length>0){const[cx,cz]=s[s.length-1],n=[];for(const[dx,dz]of[[0,-2],[0,2],[-2,0],[2,0]]){const nx=cx+dx,nz=cz+dz;if(nx>0&&nx<w-1&&nz>0&&nz<h-1&&m[nz][nx]===1)n.push([nx,nz])}if(n.length>0){const[nx,nz]=n[Math.floor(Math.random()*n.length)];m[nz][nx]=0;m[cz+(nz-cz)/2][cx+(nx-cx)/2]=0;s.push([nx,nz])}else s.pop()}return m }
        function addComplexityToMaze(m) { for(let i=0;i<MAZE_COMPLEXITY_FACTOR;i++){const x=Math.floor(Math.random()*(MAZE_SIZE-2))+1,z=Math.floor(Math.random()*(MAZE_SIZE-2))+1;if(m[z][x]===1){if((m[z][x-1]===0&&m[z][x+1]===0)||(m[z-1][x]===0&&m[z+1][x]===0))m[z][x]=0}}}
        function removeDeadEnds(m){for(let i=0;i<2;i++){const d=[];for(let z=1;z<MAZE_SIZE-1;z++)for(let x=1;x<MAZE_SIZE-1;x++)if(m[z][x]===0){let w=0;if(m[z-1][x]===1)w++;if(m[z+1][x]===1)w++;if(m[z][x-1]===1)w++;if(m[z][x+1]===1)w++;if(w>=3)d.push({x,z})}d.forEach(e=>{if(Math.random()>0.4){const p=[];if(e.z>1&&m[e.z-1][e.x]===1)p.push({x:e.x,z:e.z-1});if(e.z<MAZE_SIZE-2&&m[e.z+1][e.x]===1)p.push({x:e.x,z:e.z+1});if(e.x>1&&m[e.z][e.x-1]===1)p.push({x:e.x-1,z:e.z});if(e.x<MAZE_SIZE-2&&m[e.z][e.x+1]===1)p.push({x:e.x+1,z:e.z});if(p.length>0){const w=p[Math.floor(Math.random()*p.length)];m[w.z][w.x]=0}}})}}
        function buildMaze() { const wg=new THREE.BoxGeometry(CELL_SIZE,WALL_HEIGHT,CELL_SIZE),fg=new THREE.PlaneGeometry(MAZE_SIZE*CELL_SIZE,MAZE_SIZE*CELL_SIZE);for(let z=0;z<MAZE_SIZE;z++)for(let x=0;x<MAZE_SIZE;x++)if(mazeGrid[z][x]===1){const w=new THREE.Mesh(wg,wallMaterial);w.position.set((x-MAZE_SIZE/2+.5)*CELL_SIZE,WALL_HEIGHT/2,(z-MAZE_SIZE/2+.5)*CELL_SIZE);scene.add(w);mazeObjects.push(w)}floorMaterial.map.repeat.set(MAZE_SIZE,MAZE_SIZE);const f=new THREE.Mesh(fg,floorMaterial);f.rotation.x=-Math.PI/2;scene.add(f);mazeObjects.push(f);roofMaterial.map.repeat.set(MAZE_SIZE,MAZE_SIZE);const r=new THREE.Mesh(fg,roofMaterial);r.position.y=WALL_HEIGHT;r.rotation.x=Math.PI/2;scene.add(r);mazeObjects.push(r)}
        function findPath(s,e){const o=[s],c={},g={},f={};for(let z=0;z<MAZE_SIZE;z++)for(let x=0;x<MAZE_SIZE;x++){g[`${x},${z}`]=Infinity;f[`${x},${z}`]=Infinity}g[`${s.x},${s.z}`]=0;f[`${s.x},${s.z}`]=h(s,e);while(o.length>0){o.sort((a,b)=>f[`${a.x},${a.z}`]-f[`${b.x},${b.z}`]);const u=o.shift();if(u.x===e.x&&u.z===e.z)return p(c,u);const n=N(u.x,u.z);for(const v of n){const t=g[`${u.x},${u.z}`]+1;if(t<g[`${v.x},${v.z}`]){c[`${v.x},${v.z}`]=u;g[`${v.x},${v.z}`]=t;f[`${v.x},${v.z}`]=t+h(v,e);if(!o.some(d=>d.x===v.x&&d.z===v.z))o.push(v)}}}return[]}function h(a,b){return Math.abs(a.x-b.x)+Math.abs(a.z-b.z)}function N(x,z){const n=[],d=[[0,1],[0,-1],[1,0],[-1,0]];for(const[dx,dz]of d){const nx=x+dx,nz=z+dz;if(nx>=0&&nx<MAZE_SIZE&&nz>=0&&nz<MAZE_SIZE&&mazeGrid[nz][nx]===0)n.push({x:nx,z:nz})}return n}function p(c,u){const t=[u];while(c[`${u.x},${u.z}`]){u=c[`${u.x},${u.z}`];t.unshift(u)}return t}
        
        // --- ANIMATION LOOP AND UPDATES ---
        function updateEnemies(delta) { const p=playerObject.position,pgx=Math.floor(p.x/CELL_SIZE+MAZE_SIZE/2),pgz=Math.floor(p.z/CELL_SIZE+MAZE_SIZE/2),cwp=new THREE.Vector3();camera.getWorldPosition(cwp);for(const e of enemies){e.mesh.lookAt(cwp);e.pathCooldown-=delta;if(e.pathCooldown<=0&&pgx>=0&&pgz>=0){const n=findPath({x:e.gridX,z:e.gridZ},{x:pgx,z:pgz});if(n.length>0)e.path=n;e.pathCooldown=.5}if(e.path.length>1){const nn=e.path[1],tp=new THREE.Vector3((nn.x-MAZE_SIZE/2+.5)*CELL_SIZE,WALL_HEIGHT/2,(nn.z-MAZE_SIZE/2+.5)*CELL_SIZE),d=tp.clone().sub(e.mesh.position).normalize();e.mesh.position.add(d.multiplyScalar(ENEMY_SPEED*delta));if(e.mesh.position.distanceTo(tp)<.1){e.mesh.position.copy(tp);e.gridX=nn.x;e.gridZ=nn.z;e.path.shift()}}}}
        
        function animate() { requestAnimationFrame(animate); const t=performance.now(),d=(t-lastTime)/1e3;if(gameState==='PLAYING'){updatePlayer(d);updateEnemies(d);checkCollisions()}renderer.render(scene,camera);lastTime=t}
        function updatePlayer(delta) { 
            const settings = DIFFICULTY_SETTINGS[currentDifficulty];
            // Cooldowns and Regeneration
            if (damageCooldownTimer > 0) damageCooldownTimer -= delta;
            if (playerHealth < PLAYER_HEALTH_MAX) {
                playerHealth = Math.min(PLAYER_HEALTH_MAX, playerHealth + settings.healthRegenRate * delta);
                updateHealthBar();
            }

            const s=isSprinting&&stamina>0?PLAYER_SPRINT_SPEED:PLAYER_SPEED;playerVelocity.x-=playerVelocity.x*10*delta;playerVelocity.z-=playerVelocity.z*10*delta;const d=new THREE.Vector3();if(moveForward)d.z=1;if(moveBackward)d.z=-1;if(moveLeft)d.x=-1;if(moveRight)d.x=1;d.normalize();if(moveForward||moveBackward)playerVelocity.z+=d.z*s*delta*10;if(moveLeft||moveRight)playerVelocity.x+=d.x*s*delta*10;const pr=.8,iw=(wx,wz)=>{const gx=Math.floor(wx/CELL_SIZE+MAZE_SIZE/2),gz=Math.floor(wz/CELL_SIZE+MAZE_SIZE/2);if(gx<0||gx>=MAZE_SIZE||gz<0||gz>=MAZE_SIZE)return!0;return mazeGrid[gz]?.[gx]===1},cc=(px,pz)=>iw(px-pr,pz-pr)||iw(px+pr,pz-pr)||iw(px-pr,pz+pr)||iw(px+pr,pz+pr);const op=playerObject.position.clone();controls.moveRight(playerVelocity.x*delta);controls.moveForward(playerVelocity.z*delta);const np=playerObject.position.clone();if(cc(np.x,op.z))playerObject.position.x=op.x;if(cc(playerObject.position.x,np.z))playerObject.position.z=op.z;if(isSprinting&&(moveForward||moveBackward||moveLeft||moveRight))stamina=Math.max(0,stamina-STAMINA_DEPLETE_RATE*delta);else stamina=Math.min(STAMINA_MAX,stamina+STAMINA_REGEN_RATE*delta);updateStaminaBar()}
        
        function updateHealthBar() { healthBar.style.width = `${playerHealth}%`; }
        function updateStaminaBar() { staminaBar.style.width = `${stamina}%`; }

        function takeDamage() {
            if (damageCooldownTimer > 0) return;
            const settings = DIFFICULTY_SETTINGS[currentDifficulty];
            playerHealth = Math.max(0, playerHealth - settings.enemyDamage);
            updateHealthBar();

            damageFlash.style.animation = 'none';
            void damageFlash.offsetWidth; // Trigger reflow
            damageFlash.style.animation = 'flash 0.3s ease-out';
            
            damageCooldownTimer = settings.damageCooldown;

            if (playerHealth <= 0) {
                gameOver();
            }
        }

        function checkCollisions() { 
            if(!exitLight)return;
            for(const e of enemies) {
                if(playerObject.position.distanceTo(e.mesh.position)<CELL_SIZE/2.5){
                    takeDamage();
                }
            }
            if(playerObject.position.distanceTo(exitLight.position)<CELL_SIZE/2) winGame();
        }
        function gameOver() { gameState='GAME_OVER';controls.unlock();blocker.style.display='flex';deathScreen.style.display='block';hud.style.display='none';crosshair.style.display='none' }
        function winGame() { gameState='MENU';controls.unlock();blocker.style.display='flex';startMenu.style.display='block';startMenu.querySelector('h1').innerText="You Escaped!";startMenu.querySelector('p').innerHTML="But for how long?";hud.style.display='none';crosshair.style.display='none' }
        
        // --- EVENT LISTENERS ---
        function setupEventListeners() {
            function selectDifficultyAndStart(difficulty) {
                blocker.style.display = 'none';
                startMenu.style.display = 'none';
                controls.lock();
                startGame(difficulty);
            }

            document.getElementById('easy-button').addEventListener('click', () => selectDifficultyAndStart('EASY'));
            document.getElementById('medium-button').addEventListener('click', () => selectDifficultyAndStart('MEDIUM'));
            document.getElementById('hard-button').addEventListener('click', () => selectDifficultyAndStart('HARD'));
            document.getElementById('extreme-button').addEventListener('click', () => selectDifficultyAndStart('EXTREME'));

            resumeButton.addEventListener('click', () => { blocker.style.display = 'none'; pauseMenu.style.display = 'none'; controls.lock(); });
            restartButtonPause.addEventListener('click', () => { pauseMenu.style.display = 'none'; startGame(currentDifficulty); });
            restartButtonDeath.addEventListener('click', () => { deathScreen.style.display = 'none'; startGame(currentDifficulty); controls.lock(); });

            controls.addEventListener('lock', () => { if(gameState === 'PLAYING' || gameState === 'PAUSED') { gameState = 'PLAYING'; blocker.style.display = 'none'; pauseMenu.style.display = 'none'; hud.style.display = 'flex'; crosshair.style.display = 'block'; } });
            controls.addEventListener('unlock', () => { if (gameState === 'PLAYING') { gameState = 'PAUSED'; blocker.style.display = 'flex'; pauseMenu.style.display = 'block'; hud.style.display = 'none'; crosshair.style.display = 'none'; } });
            document.addEventListener('keydown', (e) => { switch (e.code) { case 'KeyW': moveForward=true; break; case 'KeyA': moveLeft=true; break; case 'KeyS': moveBackward=true; break; case 'KeyD': moveRight=true; break; case 'ShiftLeft': isSprinting=true; break; } });
            document.addEventListener('keyup', (e) => { switch (e.code) { case 'KeyW': moveForward=false; break; case 'KeyA': moveLeft=false; break; case 'KeyS': moveBackward=false; break; case 'KeyD': moveRight=false; break; case 'ShiftLeft': isSprinting=false; break; } });
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        }
        init();
    </script>
</body>
</html>
